{"quizz":[
{"id":1,"theme":["boucle","portée"],"niveau":0,"code":"for(var i=0; i<1; i++){}\n\nalert( i );","reponses":["0","1","2","null","undefined","Une erreur survient"],"bonneReponse":"1","explication":"En JavaScript, la portée des variables n'est affectée que par les fonctions. Les blocs de codes, comme celle des boucles, n'affectent pas la portée des variables. Ainsi déclarer une variable dans une boucle ou à l'extérieur reviendra au même et sera accessible aux mêmes endroits.<br>\nUne boucle <minicode type=\"javascript\">for</minicode> se compose de trois parties. La première est l'initialisation, elle est exécutée une seule fois au début de la boucle. La deuxième est la partie de la condition, au début de chaque itération on vérifie si la condition est vraie. Si elle l'est alors on démarre une nouvelle itération sinon on arrête la boucle. La troisième partie est celle de l'incrémentation, elle est exécutée après chaque itération.<br>\n<br>\nDans le cas de ce code, il n'y a pas de code à l'intérieur de la boucle mais celle-ci procède quand même aux différentes étapes propres aux boucle <minicode type=\"javascript\">for</minicode>. La variable <minicode type=\"javascript\">i</minicode> est initialisée à <minicode type=\"javascript\">0</minicode>. Puis on vérifie qu'elle est inférieure à <minicode type=\"javascript\">1</minicode>. Vu qu'il n'y a pas de code à exécuter, on passe directement à l'incrémentation où <minicode type=\"javascript\">i</minicode> vaut maintenant <minicode type=\"javascript\">1</minicode>). On vérifie à nouveau la condition qui est maintenant fausse, on arrête donc la boucle.<br>\nÀ la fin de la boucle <minicode type=\"javascript\">i</minicode> vaut <minicode type=\"javascript\">1</minicode> et est parfaitement accessible par la fonction <minicode type=\"javascript\">alert</minicode>."},
{"id":2,"theme":["comparaison","boucle","opérateur"],"niveau":1,"code":"var i=0, j=0;\n\ndo{\n\tj++;\n}while(i++<1);\n\nalert( i+\"/\"+j );","reponses":["0/0","0/1","0/2","1/0","1/1","1/2","2/0","2/1","2/2","Une erreur survient"],"bonneReponse":"2/2","explication":"<minicode type=\"javascript\">i++</minicode> retourne la valeur de <minicode type=\"javascript\">i</minicode> puis incrémente <minicode type=\"javascript\">i</minicode>.<br>\nDans une boucle <minicode type=\"javascript\">do … while</minicode>, le code à l'intérieur de la boucle est exécuté avant de tester la condition. Cela signifie que ce code est au moins exécuté une fois.<br>\n<br>\nAu début, le code de la boucle est exécuté (donc <minicode type=\"javascript\">j</minicode> vaut maintenant <minicode type=\"javascript\">1</minicode>). On vérifie que la valeur de <minicode type=\"javascript\">i</minicode> (qui vaut <minicode type=\"javascript\">0</minicode>) est inférieure à <minicode type=\"javascript\">1</minicode>. Puis <minicode type=\"javascript\">i</minicode> est incrémentée.<br>\nLe code de la boucle est à nouveau exécuté (donc <minicode type=\"javascript\">j</minicode> vaut maintenant <minicode type=\"javascript\">2</minicode>). On vérife que la valeur de <minicode type=\"javascript\">i</minicode> (qui vaut <minicode type=\"javascript\">1</minicode>) est inférieure à <minicode type=\"javascript\">1</minicode>. Ce qui n'est plus le cas, donc on arrête la boucle. Mais <minicode type=\"javascript\">i</minicode> est quand même incrémentée et vaut finalement <minicode type=\"javascript\">2</minicode>."},
{"id":3,"theme":["boucle","comparaison"],"niveau":0,"code":"var i = 0, j = 0;\n\nfor( i=0; i<1; i++){\n\tj++;\n}\n\nalert( i+\"/\"+j );","reponses":["0/0","0/1","0/2","1/0","1/1","1/2","2/0","2/1","2/2","Une erreur survient"],"bonneReponse":"1/1","explication":"La construction d'une boucle <minicode type=\"javascript\">for</minicode> se compose de trois parties. La première est l'initialisation, elle est exécutée une seule fois au début de la boucle. La deuxième est la partie de la condition, au début de chaque itération on vérifie si la condition est vraie. Si elle l'est alors on démarre une nouvelle itération sinon on arrête la boucle. La troisième partie est celle de l'incrémentation, elle est exécutée après chaque itération.<br>\n<br>\nAu début, on initialise <minicode type=\"javascript\">i</minicode> à <minicode type=\"javascript\">0</minicode> (qui valait déjà <minicode type=\"javascript\">0</minicode>). On vérifie la condition que <minicode type=\"javascript\">i</minicode> est inférieure à <minicode type=\"javascript\">1</minicode>. Comme elle est vraie on exécute le code de la boucle (donc <minicode type=\"javascript\">j</minicode> vaut maintenant <minicode type=\"javascript\">1</minicode>). À la fin de l'itération on incrémente <minicode type=\"javascript\">i</minicode> qui vaut donc maintenant <minicode type=\"javascript\">1</minicode>.<br>\nOn vérifie à nouveau la condition que <minicode type=\"javascript\">i</minicode> soit inférieure à <minicode type=\"javascript\">1</minicode> mais ce n'est plus le cas donc on arrête la boucle ici.<br>\nFinalement <minicode type=\"javascript\">i</minicode> vaut <minicode type=\"javascript\">1</minicode> et <minicode type=\"javascript\">j</minicode> vaut <minicode type=\"javascript\">1</minicode>."},
{"id":4,"theme":["boucle","comparaison"],"niveau":1,"code":"var i=0, j=0;\n\nwhile(i++<1){\n\tj++;\n}\n\nalert( i+\"/\"+j );","reponses":["0/0","0/1","0/2","1/0","1/1","1/2","2/0","2/1","2/2","Une erreur survient"],"bonneReponse":"2/1","explication":"<minicode type=\"javascript\">i++</minicode> retourne la valeur de <minicode type=\"javascript\">i</minicode> puis incrémente <minicode type=\"javascript\">i</minicode>.<br>\nDans une boucle <minicode type=\"javascript\">while</minicode>, le code à l'intérieur de la boucle est exécuté après le test de la condition.<br>\n<br>\nAu début, on vérifie que <minicode type=\"javascript\">i</minicode> (qui vaut <minicode type=\"javascript\">0</minicode>) est inférieure à <minicode type=\"javascript\">1</minicode>. Puis on incrémente <minicode type=\"javascript\">i</minicode>. Ensuite le code de la boucle est exécuté (donc <minicode type=\"javascript\">j</minicode> vaut maintenant <minicode type=\"javascript\">1</minicode>).<br>\nOn vérifie à nouveau que <minicode type=\"javascript\">i</minicode> (qui vaut <minicode type=\"javascript\">1</minicode>) est inférieure à <minicode type=\"javascript\">1</minicode>. Or ce n'est plus le cas, donc on arrête la boucle. Mais on incrémente quand même <minicode type=\"javascript\">i</minicode>. Le code de la boucle n'est donc pas exécuté.<br>\nFinalement <minicode type=\"javascript\">i</minicode> vaut <minicode type=\"javascript\">2</minicode> et <minicode type=\"javascript\">j</minicode> vaut <minicode type=\"javascript\">1</minicode>."},
{"id":5,"theme":["boucle","comparaison"],"niveau":0,"code":"var i=1;\nwhile(i<10){\n\ti++;\n\ti++;\n}\nalert( i );","reponses":["1","9","10","11","20","l'alert ne sera jamais appelée (boucle infinie)","Une erreur se produit"],"bonneReponse":"11","explication":"Dans une boucle <minicode type=\"javascript\">while</minicode>, le code à l'intérieur de la boucle est exécuté tant que la condition est vraie.<br>\nDans le code de la boucle, on incrémente <minicode type=\"javascript\">i</minicode> deux fois. Donc au moment des comparaisons les différentes valeurs de <minicode type=\"javascript\">i</minicode> sont&nbsp;:\n<ol style=\"list-style-type:circle;\">\n<li><minicode type=\"javascript\">1</minicode> (valeur avant la boucle)</li>\n<li><minicode type=\"javascript\">3</minicode></li>\n<li><minicode type=\"javascript\">5</minicode></li>\n<li><minicode type=\"javascript\">7</minicode></li>\n<li><minicode type=\"javascript\">9</minicode></li>\n<li><minicode type=\"javascript\">11</minicode> (à ce moment la condition devient fausse)</li>\n</ol>\nLa boucle ne s'arrête qu'au moment où la condition est testée, c'est-à-dire avant le code de la boucle. Au moment où la première incrémentation de <minicode type=\"javascript\">i</minicode> l'amène à la valeur <minicode type=\"javascript\">10</minicode>, il n'y a pas de test. Le test de la condition ne se fait qu'entre deux itérations."},
{"id":6,"theme":["déclaration"],"niveau":2,"code":"function affMessage(condition){\n\tif(condition){\n\t\tvar test = 1;\n\t}else{\n\t\tvar test = 2;\n\t}\n\talert( test );\n}\n\naffMessage(true);\naffMessage(false);","reponses":["rien","1 puis 1","1 puis 2","2 puis 1","2 puis 2","undefined puis undefined","Une erreur survient"],"bonneReponse":"1 puis 2","explication":"En JavaScript la portée des variables n'est affectée que par les fonctions et non par les blocs de code. Donc <minicode type=\"javascript\">test</minicode> est accessible dans toute la fonction <minicode type=\"javascript\">affMessage</minicode>.<br>\nBien que le \"hoisting\" effectue la déclaration de la variable <minicode type=\"javascript\">test</minicode> au début de la fonction, son affectation s'effectue au moment où l'interpréteur arrive à la ligne en question. Donc la valeur affectée à<minicode type=\"javascript\">test</minicode> est bien dépendante de la condition."},
{"id":7,"theme":["opérateur"],"niveau":0,"code":"var i = 0 || \"A\";\n\nalert( i );","reponses":["false","true","0","A","Une erreur survient"],"bonneReponse":"A","explication":"<minioce type=\"javascript\">||</minicode> correspond en JavaScript à l'opérateur logique OU. Mais contrairement à beaucoup de langages, son résultat n'est pas un forcément un booléen&nbsp;!<br>\nLe véritable fonctionnement de cet opérateur est&nbsp;: si le premier opérande est équivalent à <minicode type=\"javascript\">true</minicode> lorsqu'il est converti en booléen, alors le résultat vaut le premier opérande, sinon il vaut le deuxième opérande. Ainsi quand les deux opérandes sont des booléens, on retrouve bien l'opérateur OU du booléen (qui retourne <minicode type=\"javascript\">true</minicode> si un des deux opérandes vaut <minicode type=\"javascript\">true</minicode>). Mais quand les opérandes ne sont pas des booléens, l'interpréteur analyse leur équivalent en booléen mais retourne la valeur de l'un des deux opérandes.<br>\nUn nombre est équivalent à <minicode type=\"javascript\">false</minicode> s'il vaut <minicode type=\"javascript\">0</minicode> ou <minicode type=\"javascript\">NaN</minicode>, sinon il est équivalent à <minicode type=\"javascript\">true</minicode>.<br>\nUne chaîne de caractères est équivalente à <minicode type=\"javascript\">false</minicode> si elle vaut <minicode type=\"javascript\">\"\"</minicode> (chaîne vide), sinon elle est équivalente à <minicode type=\"javascript\">true</minicode> (même si elle vaut <minicode type=\"javascript\">\"false\"</minicode>).<br>\nUn objet est équivalent à <minicode type=\"javascript\">false</minicode> uniquement s'il vaut <minicode type=\"javascript\">null</minicode>.<br>\nUne variable non définie (<minicode type=\"javascript\">undefined</minicode>) est équivalente à <minicode type=\"javascript\">false</minicode>.<br>\n<br>\nCette écriture est très souvent utilisée pour attribuer une valeur par défaut à un argument&nbsp;:<br>\n<minicode type=\"javascript\">function f(s){</minicode><br>\n<minicode type=\"javascript\">  s = s || \"toto\"; //s vaut s (si l'argument s est défini) sinon il vaut \"toto\"</minicode><br>\n<minicode type=\"javascript\">}</minicode>"},
{"id":8,"theme":["opérateur","nombre"],"niveau":1,"code":"var i = true;\nvar j = 0;\nalert( i/j );","reponses":["0","1","Infinity","-Infinity","NaN","undefined","Une erreur survient"],"bonneReponse":"Infinity","explication":"<minicode type=\"javascript\">/</minicode> est un opérateur agissant sur des nombres. Or le premier opérande est un boolean, une conversion automatique vers le type number est effectuée. Le résultat de la conversion vaut <minicode type=\"javascript\">1</minicode>. Il s'agit donc d'estimer le résultat de l'opération <minicode type=\"javascript\">1/0</minicode>.<br>\nIl s'agit d'une division par 0. En JavaScript, le résultat d'une division par 0 se résout par <minicode type=\"javascript\">+Infinity</minicode> si le premier opérande est positif&nbsp;; <minicode type=\"javascript\">-Infinity</minicode> si le premier opérande est négatif."},
{"id":9,"theme":["nombre"],"niveau":1,"code":"var i = 0;\nvar j = 0;\nalert( i/j );","reponses":["0","1","Infinity","-Infinity","NaN","undefined","Une erreur survient"],"bonneReponse":"NaN","explication":"Par définition, en JavaScript, <minicode type=\"javascript\">0/0</minicode> vaut <minicode type=\"javascript\">NaN</minicode>  (Not A Number) car il est impossible de définir le résultat de cette opération."},
{"id":10,"theme":["opérateur","priorité","nombre"],"niveau":2,"code":"var a = 1;\nvar b = 2;\nvar c = a+++b;\nalert(a+\" \"+b+\" \"+c);","reponses":["1 2 3","1 3 3","1 3 4","2 2 3","2 2 4","1 2 NaN","1 2 undefined","Une erreur survient"],"bonneReponse":"2 2 3","explication":"La syntaxe <minicode type=\"javascript\">a+++b</minicode> est assez confuse. Il s'agit en fait de deux opérateurs&nbsp;: l'opérateur <minicode type=\"javascript\">++</minicode> et l'opérateur <minicode type=\"javascript\">+</minicode>. La syntaxe est donc juste.<br>\nCependant il faut savoir s'il s'agit de l'opération <minicode type=\"javascript\">a++ + b</minicode> ou <minicode type=\"javascript\">a + ++b</minicode>. En fait l'interpréteur donne la priorité à l'opérateur de post-incrémentation (<minicode type=\"javascript\">++</minicode>) par rapport à celui d'addition/concaténation (<minicode type=\"javascript\">+</minicode>). Il s'agit donc de l'opération <minicode type=\"javascript\">a++ + b</minicode>.<br>\n<minicode type=\"javascript\">c</minicode> vaut donc <minicode type=\"javascript\">a + b</minicode>, et <minicode type=\"javascript\">a</minicode> est incrémentée ensuite."},
{"id":11,"theme":["opérateur","priorité","nombre"],"niveau":2,"code":"\talert(typeof 1/0);","reponses":["\"number\"","\"object\"","\"string\"","\"undefined\"","Infinity","NaN","Une erreur survient"],"bonneReponse":"NaN","explication":"Il y a ici un piège. Les espaces laisse supposer que la syntaxe correspond à <minicode type=\"javascript\">typeof(1/0)</minicode>. Mais en réalité cette syntaxe comporte deux opérateurs&nbsp;: <minicode type=\"javascript\">typeof</minicode> et <minicode type=\"javascript\">/</minicode>. Entre ces deux opérateurs c'est <minicode type=\"javascript\">typeof</minicode> qui est prioritaire. Donc la syntaxe correspond en fait à <minicode type=\"javascript\">(typeof 1)/0</minicode>.<br>\nLa première opération donne donc <minicode type=\"javascript\">\"number\"</minicode> et la deuxième opération correspond à <minicode type=\"javascript\">\"number\"/0</minicode>. Or la chaine <minicode type=\"javascript\">\"number\"</minicode> ne peut être convertit en nombre et sera donc convertit en <minicode type=\"javascript\">NaN</minicode>. Or toute opération numérique su <minicode type=\"javascript\">NaN</minicode> renvoie <minicode type=\"javascript\">NaN</minicode>. Le résultat final est donc <minicode type=\"javascript\">NaN</minicode>."},
{"id":12,"theme":["opérateur"],"niveau":0,"code":"var number1 = \"2\";\nvar number2 = \"3\";\nvar resultat = number1 + number2;\n\nalert( resultat );","reponses":["5","6","23","NaN","undefined","Une erreur survient"],"bonneReponse":"23","explication":"L'opérateur <minicode type=\"javascript\">+</minicode> est à la fois l'opérateur d'addition et l'opérateur de concaténation. Lorsqu'au moins un de ses opérandes est une chaine de caractère, il agit en tant qu'opérateur de concaténation.<br>C'est le cas ici puisque, malgré leur nom, <minicode type=\"javascript\">number1</minicode> et <minicode type=\"javascript\">number2</minicode> sont des chaines de caractères. L'opération est donc une concaténation."},
{"id":13,"theme":["priorité"],"niveau":1,"code":"var calcul = \"6\" + \"5\" * 2;\nalert(parseInt(calcul, 10));","reponses":["16","22","58","112","130","610","652","NaN","Une erreur survient"],"bonneReponse":"610","explication":"Le code <minicode type=\"javascript\">\"6\" + \"5\" * 2</minicode> se découpe en deux opérations (<minicode type=\"javascript\">+</minicode> et <minicode type=\"javascript\">*</minicode>).<br>\nL'opérateur <minicode type=\"javascript\">*</minicode> est prioritaire. C'est donc l'opération <minicode type=\"javascript\">\"5\" * 2</minicode> qui est d'abord effectuée. Comme il s'agit d'un opérateur agissant sur des nombres <minicode type=\"javascript\">\"5\"</minicode> est automatiquement convertit en <minicode type=\"javascript\">5</minicode>. Le résultat vaut donc <minicode type=\"javascript\">10</minicode>.<br>\nLa deuxième opération est donc <minicode type=\"javascript\">\"6\" + 10</minicode>. L'opérateur <minicode type=\"javascript\">+</minicode> agit en tant qu'opérateur de concaténation lorsque l'un des opérandes est une chaine de caractères. <minicode type=\"javascript\">10</minicode> est donc convertit en <minicode type=\"javascript\">\"10\"</minicode> et le résultat final vaut donc <minicode type=\"javascript\">\"610\"</minicode>."},
{"id":14,"theme":["nombre"],"niveau":3,"code":"var i = Math.pow(2,53);\nvar j = i+1;\nvar k = i-1;\n\nalert( (i===j) +\" \"+ (i===k) );","reponses":["false false","false true","true false","true true","Une erreur survient"],"bonneReponse":"true false","explication":"Selon la norme IEEE 754, les nombres restent précis à l'unité près jusqu'à 2<sup>53</sup>. Au delà il faut prendre en compte la partie multiplicative (qui est codée sur 10 bits) et donc les nombres ne sont précis qu'à cette partie multiplicative près.<br>\nPour en savoir plus : <a href=\"http://www.ecma-international.org/publications/standards/Ecma-262.htm\" target=\"_blank\">Ecmascript-262 edition 5.1</a> chapitre 8.5"},
{"id":15,"theme":["objet","contexte","héritage"],"niveau":3,"code":"function Constructeur(valeur){\n\tthis.f = function(valeur){\n\t\tthis.get = function(valeur){\n\t\t\treturn this.calcul();\n\t\t};\n\t};\n\tthis.calcul = function(){\n\t\treturn valeur;\n\t};\n}\n\nvar obj1 = new Constructeur(1),\n\tobj2 = new obj1.f(2);\nalert( obj2.get(3) );","reponses":["1","2","3","undefined","Une erreur survient"],"bonneReponse":"Une erreur survient","explication":"<minicode type=\"javascript\">obj2</minicode> est construit à partir de la fonction <minicode type=\"javascript\">obj1.f</minicode>. C'est-à-dire la fonction <minicode type=\"javascript\">f</minicode> qui se trouve dans l'objet <minicode type=\"javascript\">obj1</minicode> mais dans un nouveau contexte. On n'est plus dans le contexte de <minicode type=\"javascript\">obj1</minicode> (à cause de l'opérateur <minicode type=\"javascript\">new</minicode>).<br>\nOr <minicode type=\"javascript\">calcul</minicode> n'a été affecté qu'au niveau de la fonction <minicode type=\"javascript\">Constructeur</minicode> (c'est-à-dire <minicode type=\"javascript\">obj1</minicode>). Ainsi <minicode type=\"javascript\">this.calcul</minicode> dans la fonction <minicode type=\"javascript\">get</minicode> dans le contexte de <minicode type=\"javascript\">obj2</minicode> ne fait référence à rien et vaut <minicode type=\"javascript\">undefined</minicode>. Comme on essaie de l'exécuter comme une fonction, alors une erreur survient."},
{"id":16,"theme":["objet","héritage"],"niveau":3,"code":"function Type1(){}\nType1.prototype.valeur = \"type1\";\nType1.prototype.affiche = function(){\n\tvar name = \"undefined\";\n\tif(this.constructor == Type1){\n\t\tname = \"Type1\";\n\t}\n\tif(this.constructor == Type2){\n\t\tname = \"Type2\";\n\t}\n\treturn name +\"-\"+ this.valeur;\n};\n\nfunction Type2(){}\nType2.prototype = new Type1();\nType2.prototype.valeur = \"type2\";\n\nvar obj2 = new Type2();\nalert( obj2.affiche() );","reponses":["\"Type1-type1\"","\"Type1-type2\"","\"Type2-type1\"","\"Type2-type2\"","\"undefined-type1\"","\"undefined-type2\"","Une erreur survient"],"bonneReponse":"\"Type1-type2\"","explication":"<minicode type=\"javascript\">obj2</minicode> a été contruit à partir de la fonction <minicode type=\"javascript\">Type2</minicode>. Or le prototype de <minicode type=\"javascript\">Type2</minicode> a été remplacé par un objet construit à partir de <minicode type=\"javascript\">Type1</minicode>. Ainsi <minicode type=\"javascript\">obj2</minicode> va hériter du prototype de <minicode type=\"javascript\">Type1</minicode>. Donc <minicode type=\"javascript\">obj2.affiche</minicode> donc parfaitement être appelée. <minicode type=\"javascript\">affiche</minicode> est exécutée dans le contexte de <minicode type=\"javascript\">obj2</minicode>.<br>\nAinsi <minicode type=\"javascript\">this.constructor</minicode> fait appel à la propriété de <minicode type=\"javascript\">obj2</minicode>. Cette propriété n'existe pas directement au niveau de l'objet, par héritage on regarde celle de son prototype. Or le prototype de <minicode type=\"javascript\">Type2</minicode> a été remplacé par un objet construit à partir de <minicode type=\"javascript\">Type1</minicode>. La propriété <minicode type=\"javascript\">constructor</minicode> n'existe donc toujours pas à ce niveau et il faut regarder au niveau de son prototype qui est celui de <minicode type=\"javascript\">Type1</minicode>. Ici la propriété <minicode type=\"javascript\">constructor</minicode> existe et correspond à la fonction <minicode type=\"javascript\">Type1</minicode>. Donc <minicode type=\"javascript\">name</minicode> vaudra <minicode type=\"javascript\">\"Type1\"</minicode>.<br>\nPour <minicode type=\"javascript\">this.valeur</minicode>, le procédé est le même. Sauf que la propriété <minicode type=\"javascript\">valeur</minicode> a été redéfinie sur le prototype de <minicode type=\"javascript\">Type2</minicode> après que celui-ci fut remplacé. La recherche de la propriété <minicode type=\"javascript\">valeur</valeur> s'arrêtera donc là et vaut <minicode type=\"javascript\">\"type2\"</minicode>."},
{"id":17,"theme":["objet","contexte","fonction"],"niveau":2,"code":"var myNamespace = {\n\tvaleur : 0,\n\tsubNamespace1 : {\n\t\tvaleur : 1,\n\t\tf1 : function() {\n\t\t\tvar valeur = 2;\n\t\t\tmyNamespace.subNamespace2.f2();\n\t\t}\n\t},\n\tsubNamespace2 : {\n\t\tvaleur : 3,\n\t\tf2 : function() {\n\t\t\tvar valeur = 4;\n\t\t\talert(this.valeur);\n\t\t}\n\t}\n};\n\nmyNamespace.subNamespace1.f1();","reponses":["rien","0","1","2","3","4","undefined","Une erreur survient"],"bonneReponse":"3","explication":"Il faut bien suivre le cheminement. Tout d'abord on exécute <minicode type=\"javascript\">myNamespace.subNamespace1.f1();</minicode>. C'est la fonction <minicode type=\"javascript\">f1</minicode> qui est appelée dans le contexte de <minicode type=\"javascript\">myNamespace.subNamespace1</minicode>. À ce moment <minicode type=\"javascript\">this.valeur</minicode> vaut <minicode type=\"javascript\">1</minicode>.<br>\nMais ensuite c'est la ligne <minicode type=\"javascript\">myNamespace.subNamespace2.f2();</minicode> qui est exécutée. La fonction <minicode type=\"javascript\">f2</minicode> est appelée dans le contexte de <minicode type=\"javascript\">myNamespace.subNamespace2</minicode>. Le contexte précédent n'intervient plus, donc maintenant <minicode type=\"javascript\">this.valeur</minicode> vaut <minicode type=\"javascript\">3</minicode>.<br>\n<br>\nUne variable locale n'est attachée à aucun objet. On ne peut donc y faire référence avec <minicode type=\"javascript\">this</minicode>.\n\t"},
{"id":18,"theme":["objet","héritage"],"niveau":3,"code":"function Constructeur(){\n\tthis.f = function(){};\n}\n\nvar obj1 = new Constructeur(),\n\tobj2 = new Constructeur(),\n\tobj3 = new obj1.f();\nalert(obj3 instanceof obj2.f);","reponses":["false","true","undefined","rien, une erreur est survenue"],"bonneReponse":"false","explication":"L'opérateur <minicode type=\"javascript\">instanceof</minicode> permet de vérifier si l'objet possède parmis ses prototype celui du deuxième opérande.<br>\n<br>\n<minicode type=\"javascript\">obj1</minicode> et <minicode type=\"javascript\">obj2</minicode> sont deux constructions indépendantes. Leur propriété <minicode type=\"javascript\">f</minicode> est une référence à une fonction crée à l'intérieure de la fonction <minicode type=\"javascript\">Constructeur</minicode>. Il ne s'agit donc pas de la même référence.<br>\n<minicode type=\"javascript\">obj3</minicode> est construit à partir de la fonction <minicode type=\"javascript\">f</minicode> de <minicode type=\"javascript\">obj1</minicode>. Il n'hérite donc pas du prototype de la fonction <minicode type=\"javascript\">f</minicode> de <minicode type=\"javascript\">obj2</minicode>."},
{"id":19,"theme":["objet"],"niveau":3,"code":"var obj = {};\nobj.prototype = {val:1};\nobj.constructor.prototype = {val:2};\n\nalert(obj.val);","reponses":["1","2","undefined","Une erreur survient"],"bonneReponse":"undefined","explication":"Attention&nbsp;! La propriété <minicode type=\"javascript\">prototype</minicode> n'existe que pour les fonctions (objet de héritant de l'instance function). Pour accéder au prototype d'un objet (qu'il soit littéral ou créer à partir d'une instance d'une fonction), il faut utiliser la méthode<minicode type=\"javascript\">getPrototypeOf()</minicode>. Une méthode non normalisée (mais presque standardisée, seul IE ne le supporte pas) est d'utiliser la méthode <minicode type=\"javascript\">__proto__</minicode>.<br>\nAinsi modifier la propriété <minicode type=\"javascript\">prototype</minicode> de l'objet ne permet pas de lui faire connaitre de nouvelle propriétés (si ce n'est la propriété <minicode type=\"javascript\">prototype</minicode>).<br>\n<br>\n<minicode type=\"javascript\">constructor</minicode> est une propriété issue du prototype de l'objet qui désigne la fonction ayant servit à créer l'instance de l'objet. Pour un objet littéral, il s'agit de la fonction <minicode type=\"javascript\">Object</minicode>. Toutefois modifier la référence du prototype du constructeur après la construction n'affectera pas l'instance.<br>\nPar contre il aurait été possible de rajouter une valeur au prototype du constructeur tant qu'ils partagent la même référence. Ainsi <minicode type=\"javascript\">Object.prototype.val = 0;</minicode> aurait fonctionné ainsi que <minicode type=\"javascript\">obj.constructor.prototype.val = 0;</minicode>.<br>\n<br>\nMais avec le code actuel, aucune propriété nommée <minicode type=\"javascript\">val</minicode> n'est accessible à <minicode type=\"javascript\">obj</minicode>."},
{"id":20,"theme":["objet","contexte"],"niveau":3,"code":"function Constructeur(){\n\tfunction get(){ return \"A\"; }\n\t\n\tvar o = {\n\t\tget : function(){ return \"B\"; }\n\t};\n\t\n\tthis.get = function(){ return \"C\"; };\n\t\n\treturn o;\n}\n\nConstructeur.prototype.get = function(){ return \"D\"; };\n\nfunction get(){ return \"E\"; }\n\nvar obj = new Constructeur();\nalert( obj.get() );","reponses":["\"A\"","\"B\"","\"C\"","\"D\"","\"E\"","Une erreur survient"],"bonneReponse":"\"B\"","explication":"L'opérateur <minicode type=\"javascript\">new</minicode> permet d'exécuter une fonction dans un nouveau contexte d'exécution. Ce contexte correspond à un objet ayant pour prototype celui de la fonction.<br>\nL'opérateur <minicode type=\"javascript\">new</minicode> retourne le résultat de l'appel à cette fonction si celui-ci est une référence à un objet. Sinon il retourne la référence à l'objet ayant servit de contexte à la fonction.<br>\n<br>\nVu que la fonction <minicode type=\"javascript\">Constructeur</minicode> retourne une référence à l'objet <minicode type=\"javascript\">o</minicode>. Donc le résultat de <minicode type=\"javascript\">new Constructeur</minicode> est une référence à <minicode type=\"javascript\">o</minicode>. Ainsi <minicode type=\"javascript\">obj.get()</minicode> appelera la méthode de <minicode type=\"javascript\">o</minicode> et retournera <minicode type=\"javascript\">\"B\"</minicode>.<br>\n<br>\nPour plus d'information sur l'opérateur <minicode type=\"javascript\">new</minicode>, vous pouvez consulter la spécification <a href=\"http://www.ecma-international.org/publications/standards/Ecma-262.htm\" target=\"_blank\">ECMAScript 5.1</a> aux sections 11.2.2 et 11.2.3."},
{"id":21,"theme":["objet","contexte","portée"],"niveau":3,"code":"function Constructeur(valeur){\n\tfunction calcul(){\n\t\treturn valeur;\n\t}\n\t\n\tthis.f = function(valeur){\n\t\tthis.get = function(valeur){\n\t\t\treturn calcul();\n\t\t};\n\t};\n\t\n\tthis.calcul = calcul;\n}\n\nvar obj1 = new Constructeur(1),\n\tobj2 = new obj1.f(2);\nalert( obj2.get(3) );","reponses":["1","2","3","undefined","Une erreur survient"],"bonneReponse":"1","explication":"<minicode type=\"javascript\">obj2</minicode> est construit à partir de la fonction <minicode type=\"javascript\">obj1.f</minicode>. Dans la fonction <minicode type=\"javascript\">get</minicode>, <minicode type=\"javascript\">calcul</minicode> fait référence à la fonction définit plus haut dans la fonction <minicode type=\"javascript\">Constructeur</minicode>.<br>\nLorsque la fonction <minicode type=\"javascript\">calcul</minicode> est appelée, elle cherche une variable nommé <minicode type=\"javascript\">valeur</minicode>. Aucune variable n'est nommée ainsi localement dans cette fonction et regarde donc dans l'espace de nom de son parent&nbsp;: la fonction <minicode type=\"javascript\">Constructeur</minicode>. Dans cette dernière fonction, il y a bien une déclaration de variable nommée <minicode type=\"javascript\">valeur</minicode>&nbsp;: celle de l'argument.<br>\nCette fonction <minicode type=\"javascript\">calcul</minicode> a été crée lors de la construction de <minicode type=\"javascript\">obj1</minicode>, donc <minicode type=\"javascript\">valeur</minicode> vaut <minicode type=\"javascript\">1</minicode>.<br>\nLe résultat de cette fonction n'est pas affectée par le contexte d'exécution&nbsp;!"},
{"id":22,"theme":["objet","héritage"],"niveau":3,"code":"function f(){}\n\nfunction Constructeur(){\n\tthis.f = f;\n}\n\nvar obj1 = new Constructeur(),\n\tobj2 = new Constructeur(),\n\tobj3 = new obj1.f();\nalert(obj3 instanceof obj2.f);","reponses":["false","true","undefined","rien, une erreur est survenue"],"bonneReponse":"true","explication":"L'opérateur <minicode type=\"javascript\">instanceof</minicode> permet de vérifier si l'objet possède parmis ses prototype celui du deuxième opérande.<br>\n<br>\n<minicode type=\"javascript\">obj1</minicode> et <minicode type=\"javascript\">obj2</minicode> sont deux constructions indépendantes. Leur propriété <minicode type=\"javascript\">f</minicode> est une référence à une fonction crée à l'extérieure de la fonction <minicode type=\"javascript\">Constructeur</minicode>. Il s'agit donc de la même référence.<br>\n<minicode type=\"javascript\">obj3</minicode> est construit à partir de la fonction <minicode type=\"javascript\">f</minicode> de <minicode type=\"javascript\">obj1</minicode>. Il n'hérite donc pas du prototype de la fonction <minicode type=\"javascript\">f</minicode> de <minicode type=\"javascript\">obj2</minicode>."},
{"id":23,"theme":["objet","héritage"],"niveau":4,"code":"function Constructeur(){\n\treturn new Constructeur2();\n}\n\nfunction Constructeur2(){\n}\n\nvar obj = new Constructeur();\nalert(obj instanceof Constructeur);","reponses":["false","true","undefined","rien, une erreur est survenue"],"bonneReponse":"false","explication":"L'opérateur <minicode type=\"javascript\">new</minicode> permet d'exécuter une fonction dans un nouveau contexte d'exécution. Ce contexte correspond à un objet ayant pour prototype celui de la fonction.<br>\nL'opérateur <minicode type=\"javascript\">new</minicode> retourne le résultat de l'appel à cette fonction si celui-ci est une référence à un objet. Sinon il retourne la référence à l'objet ayant servit de contexte à la fonction.<br>\n<br>\nL'opérateur <minicode type=\"javascript\">instanceof</minicode> permet de vérifier si l'objet possède parmis ses prototypes celui du deuxième opérande.<br>\n<br>\nVu que la fonction <minicode type=\"javascript\">Constructeur</minicode> retourne une référence à l'objet construit par <minicode type=\"javascript\">Constructeur2</minicode>. Donc le résultat de <minicode type=\"javascript\">new Constructeur</minicode> est uniquement une référence à un objet construit à partir de <minicode type=\"javascript\">Constructeur2</minicode> et <minicode type=\"javascript\">obj</minicode> n'hérite donc pas de <minicode type=\"javascript\">Constructeur</minicode>."},
{"id":24,"theme":["objet","héritage"],"niveau":2,"code":"function Type1(){}\nType1.prototype.affiche = function(){\n\treturn this.valeur;\n};\nType1.prototype.valeur = \"type1\";\n\nfunction Type2(){}\nType2.prototype = Type1.prototype;\nType2.prototype.valeur = \"type2\";\n\nvar obj1 = new Type1();\nvar obj2 = new Type2();\n\nalert(obj1.affiche());\nalert(obj2.affiche());","reponses":["\"type1\" puis \"type1\"","\"type1\" puis \"type2\"","\"type2\" puis \"type1\"","\"type2\" puis \"type2\"","\"type1\" une seule fois","\"type2\" une seule fois","rien, une erreur est survenue avant le premier affichage"],"bonneReponse":"\"type2\" puis \"type2\"","explication":"Le prototype de <minicode type=\"javascript\">Type2</minicode> a été remplacé par celui de <minicode type=\"javascript\">Type1</minicode>. Il font donc référence au même objet. Ainsi la ligne <minicode type=\"javascript\">Type2.prototype.valeur = \"type2\";</minicode> modifie aussi le prototype de <minicode type=\"javascript\">Type1</minicode> puisqu'il s'agit du même objet.<br>\nDonc <minicode type=\"javascript\">this.valeur</minicode> dans la fonction <minicode type=\"javascript\">affiche</minicode> fera référence à la même propriété dans les deux contextes <minicode type=\"javascript\">obj1</minicode> et <minicode type=\"javascript\">obj2</minicode>."},
{"id":25,"theme":["objet","héritage"],"niveau":3,"code":"function Constructeur(){}\n\nConstructeur.prototype.val = 0;\nConstructeur.prototype = {val:1};\nConstructeur.prototype.val = 2;\n\nvar obj = new Constructeur();\n\nConstructeur.prototype.val = 3;\nConstructeur.prototype = {val:4};\nConstructeur.prototype.val = 5;\n\nalert( obj.val );","reponses":["0","1","2","3","4","5","undefined","rien, une erreur est survenue"],"bonneReponse":"3","explication":"Au moment de la construction de <minicode type=\"javascript\">obj</minicode>, un prototype lui est assigné. À ce moment <minicode type=\"javascript\">obj</minicode> et <minicode type=\"javascript\">Constructeur</minicode> partagent le même prototype.<br>\n<minicode type=\"javascript\">Constructeur.prototype.val = 3;</minicode> va modifier la valeur de la propriété <minicode type=\"javascript\">val</minicode> du prototype de <minicode type=\"javascript\">Constructeur</minicode>. Comme le prototype de <minicode type=\"javascript\">obj</minicode> est la même référence que celui de <minicode type=\"javascript\">Constructeur</moinicode>, sa propriété <minicode type=\"javascript\">val</minicode> est aussi modifiée.<br>\n<minicode type=\"javascript\">Constructeur.prototype = {val:4};</minicode> va changer la référence du prototype de <minicode type=\"javascript\">Constructeur</minicode>. Maintenant <minicode type=\"javascript\">obj</minicode> n'a plus le même prototype que <minicode type=\"javascript\">Constructeur</minicode>.<br>\n<minicode type=\"javascript\">Constructeur.prototype.val = 5;</minicode> va modifier uniquement le prototype de <minicode type=\"javascript\">Constructeur</minicode>.<br>\nAinsi, à la fin, <minicode type=\"javascript\">obj.val</minicode> vaut <minicode type=\"javascript\">3</minicode>."},
{"id":26,"theme":["objet","contexte","portée"],"niveau":2,"code":"a=1;\nvar obj = {a:2};\n\nfunction f(){\n\tvar a=3;\n\treturn this.a;\n}\n\nfunction g(){\n\tvar a=4;\n\treturn f();\n}\n\nalert(g.call(obj));","reponses":["1","2","3","4","undefined","Une erreur survient"],"bonneReponse":"1","explication":"La fonction <minicode type=\"javascript\">g</minicode> est appelée dans le contexte de <minicode type=\"javascript\">obj</minicode>. Dans cette fonction, la fonction <minicode type=\"javascript\">f</minicode> est appelée. Mais celle-ci est appelée de manière \"classique\" et donc dans le contexte de <minicode type=\"javascript\">window</minicode> et <minicode type=\"javascript\">this</minicode> fait donc référence à <minicode type=\"javascript\">window</minicode>. Le résultat est donc <minicode type=\"javascript\">1</minicode>."},
{"id":27,"theme":["objet"],"niveau":0,"code":"var identite = {nom : \"Jean Dupont\"};\nalert(identite.prenom);","reponses":["\"Jean\"","\"Dupont\"","\"Jean Dupont\"","\"\"","undefined","Une erreur survient"],"bonneReponse":"undefined","explication":"<minicode type=\"javascript\">identite</minicode> est un objet qui ne possède qu'une seule propriété : <minicode type=\"javascript\">nom</minicode>.\nDu coup la propriété <minicode type=\"javascript\">prenom</minicode> n'existe pas, il retourne donc <minicode type=\"javascript\">undefined</minicode>.<br>\n<br>\nPour obtenir <minicode type=\"javascript\">\"Jean Dupont\"</minicode>, il aurait fallu écrire <minicode type=\"javascript\">alert(identie.nom);</minicode><br>\nPour obtenir <minicode type=\"javascript\">\"Jean\"</minicode>, il aurait fallu ajouter une propriété <minicode type=\"javascript\">prenom</minicode> ayant pour valeur <minicode type=\"javascript\">\"Jean\"</minicode> ; ou alors le récupérer depuis la propriété <minicode type=\"javascript\">nom</minicode>, par exemple <minicode type=\"javascript\">alert(identite.nom.split(\" \")[0]);</minicode>.<br>\nEt de même pour obtenir <minicode type=\"javascript\">\"Dupont\"</minicode> (en utilisant l'index 1 à la place de 0)."},
{"id":28,"theme":["fonction","déclaration"],"niveau":2,"code":"function affMessage(condition){\n\tif(condition){\n\t\tfunction leMessage(){\n\t\t\talert(\"Bonjour\");\n\t\t}\n\t}else{\n\t\tfunction leMessage(){\n\t\t\talert(\"Bonsoir\");\n\t\t}\n\t}\n\tleMessage();\n}\n\naffMessage(true);\naffMessage(false);","reponses":["rien","\"Bonjour\" puis \"Bonsoir\"","\"Bonsoir\" puis \"Bonjour\"","\"Bonjour\" puis \"Bonjour\"","\"Bonsoir\" puis \"Bonsoir\"","Une erreur survient"],"bonneReponse":"\"Bonsoir\" puis \"Bonsoir\"","explication":"Il ne faut pas oublier le principe du \"hoisting\" en JavaScript. C'est-à-dire que dans une fonction les variables sont déclarées au tout début de l'exécution de la fonction quel que soit l'endroit où cette déclaration est réalisée dans le code.<br>\nAvec des \"function declaration\", l'affectation de la fonction à la variable est réalisée au moment de la déclaration. Donc au début de l'exécution de la fonction.<br>\nAinsi dans la fonction <minicode type=\"javascript\">affMessage</minicode>, la variable <minicode type=\"javascript\">leMessage</minicode> est déclarée deux fois par des \"function declaration\". La deuxième déclaration écrasant la première, toutes références à cette variable utilisera donc la deuxième déclaration."},
{"id":29,"theme":["fonction","déclaration"],"niveau":3,"code":"var compteur = 0;\n\nvar f = function(){\n\tcompteur++;\n\tsetTimeout(f,10);\n\treturn function(){\n\t\tcompteur++;\n\t};\n}();\n\nsetTimeout(function(){\n\talert(compteur);\n},200);","reponses":["Rien","0","1","2","3","4","NaN","Une erreur se produit"],"bonneReponse":"1","explication":"Lorsque <minicode type=\"javascript\">f</minicode> est déclarée, on veut lui affecter le résultat d'une \"function expression\". En exécutant cette fonction, on commence par incrémenter <minicode type=\"javascript\">compteur</minicode> puis on lance la fonction <minicode type=\"javascript\">f</minicode> 10ms plus tard. Or à ce moment <minicode type=\"javascript\">f</minicode> n'est toujours pas définie, bien que <minicode type=\"javascript\">f</minicode> sera définie dans 10ms <minicode type=\"javascript\">setTimeout</minicode> ne s'exécutera pas mais ne provoquera pas d'erreur. <minicode type=\"javascript\">compteur</minicode> n'a donc été incrémentée qu'une seule fois."},
{"id":30,"theme":["fonction","boucle","portée"],"niveau":1,"code":"var message;\nfor(var i=0; i<10; i++){\n\tif( i == 5 ){\n\t\tmessage = function (){\n\t\t\talert(i);\n\t\t};\n\t}\n}\n\nmessage();","reponses":["0","5","6","10","11","undefined","Une erreur survient"],"bonneReponse":"10","explication":"Dans la boucle, une fonction est attribuée à la variable <minicode type=\"javascript\">message</minicode> quand <minicode type=\"javascript\">i</minicode> vaut <minicode type=\"javascript\">5</minicode>. Après la boucle, la fonction est appelée. Dans cette fonction on demande d'afficher la variable <minicode type=\"javascript\">i</minicode>. Cette variable n'existe pas au niveau de cette fonction. On regarde donc au niveau de la fonction parente (l'espace global). À ce niveau une variable <minicode type=\"javascript\">i</minicode> est bien déclarée mais sa valeur a évoluée depuis que la fonction a été affectée à la variable <minicode type=\"javascript\">message</minicode>. Et la boucle est déjà terminée. <minicode type=\"javascript\">i</minicode> vaut donc maintenant <minicode type=\"javascript\">10</minicode> (la valeur conditionnant la fin de la boucle).<br>\n<br>\nIl s'agit d'une erreur très fréquente chez ceux qui ne sont pas habitués à la notion de portée des variables en JavaScript. Il faut bien faire attention à la valeur des variables au moment où elles sont lues."},
{"id":31,"theme":["fonction","contexte"],"niveau":2,"code":"var type = \"abc\";\n\nfunction f(type){\n\treturn this.type;\n}\n\nvar test = f.bind({\n\tclick : \"def\",\n\ttype : \"click\",\n\tghi : \"jkl\"\n});\n\nalert( test(\"ghi\") );","reponses":["rien","\"abc\"","\"def\"","\"ghi\"","\"jkl\"","\"click\"","undefined","Une erreur se produit"],"bonneReponse":"\"click\"","explication":"<minicode type=\"javascript\">bind</minicode> sert à définir un contexte d'exécution à une référence de fonction. Ainsi <minicode type=\"javascript\">test</minicode> reçoit la référence à la fonction <minicode type=\"javascript\">f</minicode> dans le contexte de l'objet passé en paramètre à la méthode <minicode type=\"javascript\">bind</minicode>.<br>\nDonc quand on appelle <minicode type=\"javascript\">test</minicode>, cela appelle la fonction <minicode type=\"javascript\">f</minicode> dans le contexte de l'objet. <minicode type=\"javascript\">this.type</minicode> fait donc référence à la valeur de la propriété <minicode type=\"javascript\">type</minicode> de l'objet, c'est-à-dire <minicode type=\"javascript\">\"click\"</minicode>."},
{"id":32,"theme":["fonction"],"niveau":2,"code":"var compteur = 0;\n\nvar f = function(){\n\tcompteur++;\n\tf();\n\treturn function(){\n\t\tcompteur++;\n\t};\n}();\n\nalert(compteur);","reponses":["0","1","2","3","4","NaN","Une erreur se produit"],"bonneReponse":"Une erreur se produit","explication":"Lorsque <minicode type=\"javascript\">f</minicode> est déclarée, on veut lui affecter le résultat d'une \"function expression\". En exécutant cette fonction, on commence par incrémenter <minicode type=\"javascript\">compteur</minicode> puis on lance la fonction <minicode type=\"javascript\">f</minicode>. Or à ce moment <minicode type=\"javascript\">f</minicode> n'est toujours pas définie. Une erreur se produit alors puisque <minicode type=\"javascript\">f</minicode> ne fait pas référence à une fonction."},
{"id":33,"theme":["fonction","déclaration","portée"],"niveau":3,"code":"var compteur = 0;\n\nfunction f(){\n\tcompteur++;\n}\n\nvar g = function f(){\n\tcompteur += 2;\n\tif( compteur<3 ){\n\t\tf();\n\t}\n}();\n\nf();\n\nalert(compteur);","reponses":["0","1","2","3","4","5","6","undefined","Une erreur survient"],"bonneReponse":"5","explication":"<minicode type=\"javascript\">g</minicode> reçoit le résultat d'une fonction nommée <minicode type=\"javascript\">f</minicode>. Il s'agit là d'une \"function expression\", son nom n'est donc pas affecté à l'espace de nom mais il est accessible à l'intérieur de celle-ci. Ainsi lors de l'exécution, elle se rappelle bien elle-même. Cela crée donc une boucle récursive jusqu'à ce que <minicode type=\"javascript\">compteur</minicode> soit supérieure ou égal à <minicode type=\"javascript\">3</minicode>. La variable <minicode type=\"javascript\">compteur</minicode> s'incrémentant alors de 2 en 2, la boucle s'arrête quand <minicode type=\"javascript\">compteur</minicode> vaut <minicode type=\"javascript\">4</minicode>.<br>\nEnsuite on appelle la fonction <minicode type=\"javascript\">f</minicode>. Cette fois-ci il s'agit de la fonction qui a été déclarée au début. Car une foncion déclarée en \"function declaration\" déclare une variable et lui affecte une référence d'elle-même (ce que ne font pas les \"function expression\"). <minicode type=\"javascript\">compteur</minicode> est donc incrémenté de 1.<br>\nLa valeur finale de <minicode type=\"javascript\">compteur</minicode> est donc de <minicode type=\"javascript\">5</minicode>."},
{"id":34,"theme":["Array"],"niveau":0,"code":"var liste = [1, 2, 3];\nalert( liste[2] );","reponses":["1","2","3","123","Array","null","undefined","Une erreur survient"],"bonneReponse":"3","explication":"<minicode type=\"javascript\">liste[2]</minicode> correspond à la valeur située à l'index 2 de la liste. C'est-à-dire à la 3<sup>e</sup> position car la première position correspond à l'index 0."},
{"id":35,"theme":["Array"],"niveau":2,"code":"var liste = [0, 1, 2, 3];\nliste.length = 5;\nliste.push(4);\nalert( liste[4] );","reponses":["0","4","\"\"","null","NaN","undefined","Une erreur survient"],"bonneReponse":"undefined","explication":"<minicode type=\"javascript\">push</minicode> ajoute un élément à la dernière position. La dernière position est indiquée par l'attribut <minicode type=\"javascript\">length</minicode>. Or celui-ci a été modifié. La valeur <minicode type=\"javascript\">4</minicode> est donc ajouté à l'index 5. Et la valeur située à l'index 4 est n'est toujours pas définie et vaut donc <minicode type=\"javascript\">undefined</minicode>."},
{"id":36,"theme":["Array"],"niveau":2,"code":"var liste = [0, 1, 2, 3, 4, 5];\nliste.length = 4;\nalert( liste[4] );","reponses":["0","3","4","5","\"\"","NaN","undefined","Une erreur survient"],"bonneReponse":"undefined","explication":"<minicode type=\"javascript\">length</minicode> est un attribut éditable. Lorsque celui-ci est modifié les éléments situés après sont supprimés. Si on essaie d'y accéder on obtient donc <minicode type=\"javascript\">undefined</minicode>."},
{"id":37,"theme":["Array"],"niveau":1,"code":"var liste = [0, 1, 2, 3];\nliste.length = 5;\nalert( liste[4] );","reponses":["0","4","\"\"","null","NaN","undefined","Une erreur survient"],"bonneReponse":"undefined","explication":"<minicode type=\"javascript\">length</minicode> est un attribut éditable. Lorsque celui-ci est modifié les éléments situés avant ne sont pas modifié et aucune variable ou objet n'est créé. Du coup la valeur à l'index 4 n'est toujours pas définie et vaut donc <minicode type=\"javascript\">undefined</minicode>."},
{"id":38,"theme":["Array"],"niveau":1,"code":"var liste = [1024, 512, 32].sort();\nalert(liste.join(\",\"));","reponses":["32,512,1024","32,1024,512","512,32,1024","512,1024,32","1024,32,512","1024,512,32","Une erreur survient"],"bonneReponse":"1024,32,512","explication":"Le fonctionnement par défaut de <minicode type=\"javascript\">sort</minicode> agit sur les strings. Ainsi les nombres sont convertis en string et sont triés en tant que chaînes de caractères. Or 1 est avant 3 dans l'ordre alphabétique, et donc <minicode type=\"javascript\">1024</minicode> est avant <minicode type=\"javascript\">32</minicode>."},
{"id":39,"theme":["regexp"],"niveau":3,"code":"var r = /(?<=[a-z])/gi;\nvar s =\"Des questions\";\nalert(s.replace(r,\"@\"));","reponses":["\"Des questions\"","\"@ @\"","\"@@@ @@@@@@@@@\"","\"@es questions\"","\"@Des questions\"","\"@Des @questions\"","\"@D@e@s @q@u@e@s@t@i@o@n@s\"","\"D@e@s@ q@u@e@s@t@i@o@n@s@\"","\"@D@e@s@ @q@u@e@s@t@i@o@n@s@\"","Une erreur survient"],"bonneReponse":"Une erreur survient","explication":"Les assertions arrières (?&lt;=) et (?&lt;!) ne sont pas supportées en JavaScript. La syntaxe n'est donc pas valide."},
{"id":40,"theme":["regexp"],"niveau":3,"code":"var r = /(?=[a-z])/gi;\nvar s =\"Des questions\";\nalert(s.replace(r,\"@\"));","reponses":["\"Des questions\"","\"@ @\"","\"@@@ @@@@@@@@@\"","\"@es questions\"","\"@Des questions\"","\"@Des @questions\"","\"@D@e@s @q@u@e@s@t@i@o@n@s\"","\"D@e@s@ q@u@e@s@t@i@o@n@s@\"","\"@D@e@s@ @q@u@e@s@t@i@o@n@s@\"","Une erreur survient"],"bonneReponse":"\"@D@e@s @q@u@e@s@t@i@o@n@s\"","explication":"Le motif de l'expression régulière cherche une chaine qui correspond à une suite de caractère alphabétique. Mais cette recherche se fait dans une assertion avant donc les caractères trouvés ne font pas partis du motif. Comme il n'y a aucun autre caractère spécifié en dehors de l'assertion, le motif ne contiendra aucun caractère.<br>\nAinsi lors du remplacement, avant chaque caractère alphabétique est inséré un caractère <minicode type=\"javascript\">@</minicode>."},
{"id":41,"theme":["regexp"],"niveau":1,"code":"var r = /^[a-z \\-\\^]+$/;\nvar s =\"ceci]est mon texte\";\nalert(r.test(s));","reponses":["false","true","undefined","Une erreur survient"],"bonneReponse":"false","explication":"Le motif de l'expression régulière cherche une chaine qui commence et finit par une suite de caractères correspondant à des lettres minuscules, des espaces, des moins (-) ou des accents circonflexes (^). Or dans la chaine à tester il y a un caractère qui ne fait pas partie de cette liste&nbsp;: le crochet fermant (]).<br>\nDonc le résultat de la rechereche est un échec."},
{"id":42,"theme":["regexp"],"niveau":2,"code":"var r = /[a-z]+?/g;\nvar s =\"Des questions\";\nalert(s.replace(r,\"@\"));","reponses":["\"Des questions\"","\"@\"","\"@ @\"","\"@es questions\"","\"D@s questions\"","\"@ questions\"","\"Des @\"","\"D@ @\"","\"D@@ @@@@@@@@@\"","\"@@@ @@@@@@@@@\"","Une erreur survient"],"bonneReponse":"\"D@@ @@@@@@@@@\"","explication":"Le motif de l'expression régulière cherche une chaine qui correspond à une suite de caractère alphabétique minuscule. Les symboles <minicode type=\"javascript\">+?</minicode> signifie que l'on en recherche au moins 1 mais le plus petit nombre possible (méthode non gourmande). Comme il n'y a aucune spécification derrière ces symboles, la recherche se contentera d'un seul caractère.<br>\nAinsi lors du remplacement, tous les caractères alphabétiques minuscules sont remplacés par <minicode type=\"javascript\">@</minicode>."},
{"id":43,"theme":["regexp"],"niveau":1,"code":"var r = new RegExp(\"/test/\",\"g\");\nvar s =\"Test d'un test pour tester\";\nalert( s.match(r)+\"\" );","reponses":["Test","test","test,test","Test,test,test","null","Une erreur survient"],"bonneReponse":"null","explication":"Pour créer une ReGexp on peut soit utiliser la notation littéralle (<minicode type=\"javascript\">/motif/</minicode>), soit utiliser le constructeur. Pour ce dernier le premier argument est une chaine de caractères qui correpond au motif à rechercher. Or ici la chaine à rechercher est <minicode type=\"javascript\">\"/test/\"</minicode>, c'est-à-dire avec les /. or le texte ne possède aucun / donc il n'y a aucun motif trouvé par l'expression régulière."},
{"id":44,"theme":["priorité"],"niveau":2,"code":"var i = 0;\nvar tab = [];\ntab[i++] = i;\ntab[i++] = i;\ntab[i++] = i++;\n\nalert( tab.join(',') );","reponses":["0,1,2","0,1,,2","0,1,,3","1,2,3","1,2,,3",",1,2,3","0",",1","\"\"","Une erreur survient"],"bonneReponse":"1,2,3","explication":"Une expression est interprétée de gauche à droite. L'interpréteur commence par remplacer les valeurs de toutes les variables ou tous les appels de fonctions. Puis il effectue les opérations selon leur priorité.<br>\n<minicode type=\"javascript\">tab[i++] = i;</minicode>, au départ <minicode type=\"javascript\">i</minicode> vaut <minicode type=\"javascript\">0</minicode>. on affecte don au premier élément (index 0) de <minicode type=\"javascript\">tab</minicode> la valeur du deuxième opérande. Pour ce dernier <minicode type=\"javascript\">i</minicode> a déjà été incrémentée lors de l'interprétation de l'expression du premier opérande et vaut donc <minicode type=\"javascript\">1</minicode>."},
{"id":45,"theme":["objet","opérateur"],"niveau":3,"code":"var val=0;\nfunction inc(){\n  return val++;\n}\n\nvar obj={};\nObject.defineProperty(obj,\"s\",{\n\t\tget : inc,\n\t\tset : inc\n\t});\n\nobj.v = obj.s = obj.s = 100;\n\nalert(obj.v+obj.s);","reponses":["3","4","6","7","8","102","104","200","201","NaN","Une erreur survient"],"bonneReponse":"102","explication":"Ici, il faut bien faire attention à ce que retourne l'opérateur d'affectation (<minicode type=\"javascript\">=</minicode>) dans le cadre d'une expression. Cet opérateur affecte à la variable du premier opérande le résultat du deuxième opérande. Mais le retour de cet opérateur est le deuxième opérande.<br>\nAinsi dans <minicode type=\"javascript\">obj.s = obj.s = 100</minicode>, le get de <minicode type=\"javascript\">obj.s</minicode> n'est pas appelé. Et donc c'est la valeur <minicode type=\"javascript\">100</minicode> qui est affecté à la variable <minicode type=\"javascript\">obj.v</minicode>.<br>\nDans l'opération <minicode type=\"javascript\">obj.s = obj.s = 100</minicode>, on essaie d'affecter deux fois la valeur <minicode type=\"javascript\">100</minicode> à <minicode type=\"javascript\">obj.s</minicode>. Son setter est donc appelé deux fois, et la variable <minicode type=\"javascript\">val</minicode> est incrémentée deux fois.<br>\nLors de la lecture le getter renvoie la valeur de <minicode type=\"javascript\">val</minicode> avant de l'incrémenter et retourne donc <minicode type=\"javascript\">2</minicode>. Le calcul final correspond à <minicode type=\"javascript\">100+2</minicode> qui vaut <minicode type=\"javascript\">102</minicode>."},
{"id":46,"theme":["priorité","opérateur"],"niveau":2,"code":"var i = 1;\n\nalert( i + i++ - i++ * i++ );","reponses":["-9","-5","-4","-1","0","1","4","5","9","NaN","Une erreur survient"],"bonneReponse":"-4","explication":"Une expression est interprétée de gauche à droite. L'interpréteur commence par remplacer les valeurs de toutes les variables ou de tous les appels de fonctions. Puis il effectue les opérations selon leur priorité.<br>\nDonc <minicode type=\"javascript\">i + i++ - i++ * i++</minicode> est remplacé par <minicode type=\"javascript\">1 + 1 - 2 * 3</minicode>. L'opération de multiplication (<minicode type=\"javascript\">*</minicode>) étant prioritaire, le calcul suivant est donc <minicode type=\"javascript\">1 + 1 - 6</minicode>. Ce qui amène au résultat de <minicode type=\"javascript\">-4</minicode>."},
{"id":47,"theme":["comparaison","Array"],"niveau":1,"code":"var arr1 = [];\nvar arr2 = [];\n\nalert(arr1 == arr2);\nalert(arr1 === arr2);","reponses":["false puis false","false puis true","true puis false","true puis true","Une erreur se produit"],"bonneReponse":"false puis false","explication":"Les tableaux sont des objets. leur comparaison se fait donc par leur référence. Ils sont des instances différentes et ne sont donc jamais égales.<br>\n<br>\n<br>\nPour plus d'information vous pouvez consulter les algorithmes définis par la spécification <a href=\"http://www.ecma-international.org/publications/standards/Ecma-262.htm\" target=\"_blank\">ECMAScript 5.1</a> aux sections 11.9.3 (pour l'égalité abstraite) et 11.9.6 (pour l'égalité stricte)."},
{"id":48,"theme":["comparaison","priorité"],"niveau":1,"code":"function verif(nb){\n\tif( 5 < nb < 15){\n\t\talert(\"OK\");\n\t}\n}\n\nverif(10);\nverif(20);","reponses":["rien","OK apparait 1 fois","OK apparait 2 fois","Une erreur se produit"],"bonneReponse":"OK apparait 2 fois","explication":"Il faut faire attention à la priorité des opérateurs. <minicode type=\"javascript\">5 < nb < 15</minicode> correspond à deux opérations ! La première est <minicode type=\"javascript\">5 < nb</minicode>. Et la deuxième est <minicode type=\"javascript\">X < 15</minicode> où X est le résultat de la première opération.<br>\nOr les deux fois où la fonction verif est appelé, <minicode type=\"javascript\">nb</minicode> est supérieure à 5. Donc la première opération retourne <minicode type=\"javascript\">true</minicode> dans les deux cas.<br>\nL'opération <minicode type=\"javascript\">true < 15</minicode> correspond à l'opération <minicode type=\"javascript\">1 < 15</minicode> et vaut donc aussi <minicode type=\"javascript\">true</minicode>."},
{"id":49,"theme":["comparaison"],"niveau":1,"code":"alert( \"abc\" < \"VWXYZ\" );","reponses":["true","false","\"abcVWYZ\"","NaN","Une erreur se produit"],"bonneReponse":"false","explication":"Il s'agit en fait d'une question piège. L'opérateur <minicode type=\"javascript\"><</minicode> appliqué à des chaines de caractères ne les compare pas alphabétiquement et non pas selon leur longueur mais selon la valeur des caractères composant la chaine (le <minicode type=\"javascript\">charCode</minicode>).<br>\nAinsi les premiers caractères de ces chaines (<minicode type=\"javascript\">'a'</minicode> et <minicode type=\"javascript\">'V'</minicode>) ont pour valeurs respectives <minicode type=\"javascript\">97</minicode> et <minicode type=\"javascript\">86</minicode>. En JavaScript la chaine <minicode type=\"javascript\">\"VWXYZ\"</minicode> se situe donc avant la chaine <minicode type=\"javascript\">\"abc\"</minicode>.<br>\n<br>\nPour obtenir <minicode type=\"javascript\">true</minicode>, il aurait fallu comparer des chaines ayant la même casse (par exemple <minicode type=\"javascript\">alert( \"ABC\"<\"VWXYZ\" )</minicode> ou <minicode type=\"javascript\">alert( \"abc\"<\"vwxyz\" )</minicode>). C'est pourquoi quand on ordonne des chaines les méthodes <minicode type=\"javascript\">toUpperCase</minicode> ou <minicode type=\"javascript\">toLowerCase</minicode> peuvent être très utile.<br>\n<br>\nEn JavaScript, l'opérateur de concaténation est le <minicode type=\"javascript\">+</minicode> ainsi avec <minicode type=\"javascript\">alert(\"abc\" + \"VWXYZ\");</minicode> on obtient <minicode type=\"javascript\">\"abcVWXYZ\"</minicode>.<br>\n<br>\nPour obtenir <minicode type=\"javascript\">NaN</minicode>, il aurait fallu utiliser un opérateur ne fonctionnant qu'avec des nombres."},
{"id":50,"theme":["comparaison"],"niveau":1,"code":"var i = \"1\";\nvar c = \"1\";\n\nswitch(i){\n\tcase c: alert(\"c\"); break;\n\tcase 1: alert(\"number\"); break;\n\tcase \"1\": alert(\"string\"); break;\n\tdefault: alert(\"other\");\n}","reponses":["\"c\"","\"number\"","\"string\"","\"other\"","Plusieurs alert s'affichent","Une erreur se produit"],"bonneReponse":"\"c\"","explication":"<minicode type=\"javascript\">switch</minicode> correspond à des comparaisons strictes. Or <minicode type=\"javascript\">c</minicode> vaut <minicode type=\"javascript\">\"1\"</minicode> et <minicode type=\"javascript\">i</minicode> aussi. Donc <minicode type=\"javascript\">switch</minicode> arrête sa recherche dès le premier cas."},
{"id":51,"theme":["comparaison","objet"],"niveau":2,"code":"var s1 = new String(\"toto\");\nvar s2 = new String(\"toto\");\nvar r1 = /toto/g;\nvar r2 = /toto/g;\nvar compteur = 0;\n\nif(s1 == s2) compteur++;\nif(s1 === s2) compteur++;\n\nif(r1 == r2) compteur++;\nif(r1 === r2) compteur++;\n\nif(s1 == r1) compteur++;\nif(s1 === r1) compteur++;\n\nalert(compteur);","reponses":["0","1","2","3","4","5","6","Une erreur se produit"],"bonneReponse":"0","explication":"Il faut bien comprendre les opérateurs de comparaison et ne pas oublier que <minicode type=\"javascript\">alert(typeof new String(\"toto\"))</minicode> vaut <minicode type=\"javascript\">\"object\"</minicode> et non pas <minicode type=\"javascript\">\"string\"</minicode>.<br>\n<br>\nAvec des objets, les opérateurs d'égalité (que ce soit <minicode type=\"javascript\">==</minicode> ou <minicode type=\"javascript\">===</minicode>) ne retournent <minicode type=\"javascript\">true</minicode> que si les deux opérandes font références au même objet.<br>\n<br>\nOr <minicode type=\"javascript\">new String</minicode> crée une nouvelle instance. Ces variables ne sont donc pas égales.<br>\nC'est la même chose avec les RegExp (même écrit en littéral) car chaque objet possède son propre statut (positionnement du curseur, etc.). Ainsi les variables ne font pas référence au même objet bien que ceux-ci ont été écrit de la même manière.<br>\n<br>\n<br>\n<information>L'opérateur <minicode type=\"javascript\">==</minicode> n'est pas transitif. On peut remarquer que <minicode type=\"javascript\">\"a\" == \"a\"</minicode> et <minicode type=\"javascript\">\"a\" == new String(\"a\")</minicode> valent <minicode type=\"javascript\">true</minicode>. Mais <minicode type=\"javascript\">new String(\"a\") == new String(\"a\")</minicode> vaut <minicode type=\"javascript\">false</minicode>.</information><br>\n<br>\n<br>\nPour plus d'information vous pouvez consulter les algorithmes définis par la spécification <a href=\"http://www.ecma-international.org/publications/standards/Ecma-262.htm\" target=\"_blank\">ECMAScript 5.1</a> aux sections 11.9.3 (pour l'égalité abstraite) et 11.9.6 (pour l'égalité stricte)."},
{"id":52,"theme":["portée"],"niveau":0,"code":"var a = 1;\nfunction f1(){\n\ta = 2;\n}\n\nfunction f2(){\n\talert(a);\n}\n\nf1();\nf2();","reponses":["1","2","undefined","Une erreur se produit"],"bonneReponse":"2","explication":"Dans la fonction <minicode type=\"javascript\">f1</minicode>, la variable <minicode type=\"javascript\">a</minicode> n'est pas déclarée. Ce sera donc la variable portant ce nom de l'espace parent qui sera utilisée. Ainsi la variable <minicode type=\"javascript\">a</minicode> déclarée au tout début est modifiée par <minicode type=\"javascript\">f1</minicode> et vaut maintenant <minicode type=\"javascript\">2</minicode>.<br>\nDans la fonction <minicode type=\"javascript\">f2</minicode>, la variable <minicode type=\"javascript\">a</minicode> n'est pas déclarée. Ce sera donc la variable portant ce nom de l'espace parent qui sera utilisée. C'est donc la variable <minicode type=\"javascript\">a</minicode> déclarée au tout début qui est affichée (et qui vaut <minicode type=\"javascript\">2</minicode> depuis la modification faite par <minicode type=\"javascript\">f1</minicode>)."},
{"id":53,"theme":["portée"],"niveau":5,"code":"\nvar toto = \"abc\";\n\nfunction f(){\n\n\talert(\"def\");\n\n}\n\n\n\ntry{\n\n\tthrow \"une erreur\"; //génère une erreur qui est capturée par le catch\n\n}catch(toto){\n\n\ttoto = \"ghi\";\n\n\tvar f = function () {\n\n\t   alert(toto);\n\n\t}\n\n}\n\n\n\nf();","reponses":["\"abc\"","\"def\"","\"ghi\"","undefined","Une erreur survient (qui n'est pas capturée)"],"bonneReponse":"\"ghi\"","explication":"La variable <minicode type=\"javascript\">f</minicode> qui est dans le <minicode type=\"javascript\">try … catch</minicode> est déclarée dans l'espace de noms principal (principe du \"hoisting\") et fait référence au même nom que la fonction <minicode type=\"javascript\">f</minicode>. Mais sa nouvelle affectation se fait dans le bloc <minicode type=\"javascript\">catch</minicode> et son espace de noms parent est donc celui de <minicode type=\"javascript\">catch</minicode>. Ainsi <minicode type=\"javascript\">toto</minicode> correspond à celui qui est modifié dans ce bloc et vaudra <minicode type=\"javascript\">\"ghi\"</minicode>.<br>\n\nComme la variable <minicode type=\"javascript\">f</minicode> a été enregistrée dans l'espace de nom principal (et a été assigné dans le bloc <minicode type=\"javascript\">catch</minicode>), elle est tout à fait accessible après ce bloc."},
{"id":54,"theme":["chaînes de caractères"],"niveau":0,"code":"var t1 = \"l\\'eau \\\"bleue\\\"\";\nvar t2 = 'l\\'eau \\\"bleue\\\"';\nalert(t1 == t2);","reponses":["false","true","undefined","Une erreur se produit"],"bonneReponse":"true","explication":"En JavaScript, les chaînes de caractères peuvent être formées à partir d'apostrophes ('), ou de quillemets (\"). Ces deux écritures sont absolument identiques et il est possible d'échapper les caractères à l'aide de \\ dans les deux cas. Il ne faut pas confondre avec d'autres langages, où l'utilisation de l'une ou l'autre forme influe sur le comportement.<br>\nLa seule différence entre ces deux écritures réside dans le fait qu'il n'est pas nécessaire d'échapper les apostrophes dans une chaine construite à partir de guillemets (et réciproquement). Bien qu'il ne soit pas obligatoire de les échapper, l'échappement est possible et est quand même pris en compte."},
{"id":55,"theme":["portée","fonction"],"niveau":3,"code":"var f = function g(){\n\treturn 1;\n};\n\nalert( typeof g );","reponses":["boolean","function","number","object","string","undefined","Une erreur se produit"],"bonneReponse":"undefined","explication":"La fonction <minicode type=\"javascript\">g</minicode> est une \"function expression\". Cela signifie qu'elle n'existe que dans cette expression (sauf si on a sauvegardé sa référence). Ainsi aucune variable n'est crée pour utiliser son nom. Donc <minicode type=\"javascript\">g</minicode> n'est pas définit."},
{"id":56,"theme":["comparaison"],"niveau":0,"code":"var c1 = 0 == \"\";\nvar c2 = 0 == \"0\";\nvar c3 = \"\" == \"0\";\n\nalert(c1 +\" \"+ c2 +\" \"+ c3);","reponses":["false false false","false false true","false true false","false true true","true false false","true false true","true true false","true true true","undefined","Une erreur se produit"],"bonneReponse":"true true false","explication":"Lorsqu'une comparaison a lieu avec l'opérateur <minicode type=\"javascript\">==</minicode> et que les opérandes ne sont pas du même type, une conversion automatique vers le même type est effectuée.<br>\nLorsque l'un des deux opérandes est un nombre, pour la comparaison, l'autre est convertit en nombre. <minicode type=\"javascript\">Number(\"0\")</minicode> vaut <minicode type=\"javascript\">0</minicode> et <minicode type=\"javascript\">Number(\"\")</minicode> aussi (cf spécification <a href=\"http://www.ecma-international.org/publications/standards/Ecma-262.htm\" target=\"_blank\">ECMAScript 5.1</a> section 9.3.1). Donc les deux premières comparaisons vallent <minicode type=\"javascript\">true</minicode>.<br>\nLa troisième comparaison est une comparaison entre deux opérandes de même type. C'est donc leur valeur qui est comparée et celles-ci ne sont pas égales. Cette dernière comparaison vaut donc <minicode type=\"javascript\">false</minicode> bien que ces deux opérandes soient équivalents à <minicode type=\"javascript\">0</minicode>.<br>\n<br>\nPour plus d'information sur l'opérateur de comparaison, vous pouvez consulter la spécification <a href=\"http://www.ecma-international.org/publications/standards/Ecma-262.htm\" target=\"_blank\">ECMAScript 5.1</a> à la section 11.9"},
{"id":57,"theme":["portée","contexte","déclaration"],"niveau":5,"code":"var toto = \"abc\";\n\nfunction f(){\n\talert(\"def\");\n}\n\ntry{\n\tthrow \"une erreur\"; //génère une erreur qui est capturée par le catch\n}catch(toto){\n\ttoto = \"ghi\";\n\tfunction f() {\n\t   alert(toto);\n\t}\n\tf();\n}","reponses":["\"abc\"","\"def\"","\"ghi\"","undefined","Une erreur survient (qui n'est pas capturée)"],"bonneReponse":"\"abc\"","explication":"Attention&nbsp;! Firefox ne résout pas correctement ce code&nbsp;! Selon la norme définie par le ECMAScript, il s'agirait d'un bug de Firefox. Mais son comportement est sans doute plus proche de ce que de nombreuses personnes s'attendent à obtenir. Chrome, Internet Explorer, Opera, et Safari répondent correctement.<br>\nRemarquez aussi que ce code n'est pas valide en mode strict et la confusion et donc peu probable.<br>\n<br>\n<br>\nEn JavaScript, chaque fonction possède un espace de noms qui lui est propre et possède une référence vers l'espace de noms de son parent (c'est le principe de la portée des variables).<br>\nPour la gestion des noms de variables, il existe deux pointeurs internes qui permettent d'indiquer quel espace de noms choisir pour enregistrer ou accéder aux variables. Le premier est le \"LexicalEnvironment\" (lexique de l'environnement) qui permet d'indiquer quel espace de nom choisir lorsqu'on désire accéder à la valeur d'une variable. Il est utilisé pour la lecture et l'écriture durant l'exécution du code. Le deuxième pointeur est le \"VariableEnvironment\" (variables de l'environnement) qui permet d'indiquer dans quel espace de nom il faut écrire les nouvelles variables.<br>\nDans la majeure partie du temps, ces deux pointeurs indiquent le même espace de noms. Ils diffèrent uniquement dans les environnements temporaires. Cette différence permet aux nouvelles variables déclarées dans ces environnements temporaires d'être accessibles à l'extérieur de ces blocs (car la portée des variables doit être celle de la fonction). Les environnements temporaires correspondent à des zones de codes qui peuvent accéder à des variables qui ne sont pas accessibles à l'extérieur de ces zones. Cela arrive dans le bloc <minicode type=\"javascript\">catch</minicode> de <minicode type=\"javascript\">try … catch</minicode> (où il est possible d'accéder à l'erreur grâce à une variable) et dans le bloc <minicode type=\"javascript\">with</minicode> dans lequel toutes les propriétés de l'objet sont accessibles sans avoir à préciser le nom de l'objet en préfixe.<br>\nCela reste imperceptible quand l'affectation de cette variable est réalisée dans le bloc. Toutefois dans le cas d'une \"function declaration\" l'affectation de la variable se fait au moment de la déclaration.<br>\nAinsi la fonction <minicode type=\"javascript\">f</minicode> située dans le <minicode type=\"javascript\">catch</minicode> est déclarée dans l'espace de noms principal car VariableEnvironment pointe sur cet espace de noms et remplace la précédente déclaration de <minicode type=\"javascript\">f</minicode>. Comme il s'agit d'une \"function declaration\", un nouvel environnement est créé pour cette fonction. Son espace de noms parent correspond à celui du pointeur LexicalEnvironment. Or à ce moment LexicalEnvironment pointe toujours sur l'espace de noms principal, car nous sommes au début de l'exécution de la fonction (principe du \"hoisting\").<br>\nAinsi lors de l'exécution de cette fonction, l'environnement temporaire du <minicode type=\"javascript\">catch</minicode> est inconnu pour cette fonction et c'est donc l'espace principal qui est utilisé.<br>\nLa variable <minicode type=\"javascript\">toto</minicode>, dans le bloc <minicode type=\"javascript\">catch</minicode>, par contre appartient à l'espace de noms de l'environnement temporaire de <minicode type=\"javascript\">catch</minicode>. Ainsi sa modification n'affecte pas la variable déclarée dans l'espace globale (à laquelle la fonction <minicode type=\"javascript\">f</minicode> fait référence).\n<br>\nPour plus d'information sur la gestion des espaces de noms, vous pouvez consulter la spécification <a href=\"http://www.ecma-international.org/publications/standards/Ecma-262.htm\" target=\"_blank\">ECMAScript 5.1</a> aux sections 10.2 et 10.3."},
{"id":58,"theme":["déclaration"],"niveau":1,"code":"var a = 1;\na = 2;\n\nvar a;\n\nalert(a);","reponses":["0","1","2","undefined","Une erreur se produit"],"bonneReponse":"2","explication":"En JavaScript, la déclaration des variables se fait avant toutes actions (principe du \"hoisting\"). Ainsi la déclaration d'une nouvelle variable <minicode type=\"javascript\">a</minicode> après l'affectation de la ligne <minicode type=\"javascript\">a = 2;</minicode> n'a aucun impact sur le résultat. La ligne <minicode type=\"javascript\">var a;</minicode> est simplement ignorée."},
{"id":59,"theme":["fonction"],"niveau":0,"code":"function f(){\n\treturn true;\n};\n\nvar g = f;\n\nalert( g() );","reponses":["false","true","null","undefined","Une erreur se produit"],"bonneReponse":"true","explication":"<minicode type=\"javascript\">f</minicode> est une fonction. <minicode type=\"javascript\">var g = f;</minicode> signifie que <minicode type=\"javascript\">g</minicode> récupère une référence à la focntion <minicode type=\"javascript\">f</minicode>. Il est donc possible d'exéctuer <minicode type=\"javascript\">g</minicode> et c'est la fonction <minicode type=\"javascript\">f</minicode> qui sera appellée."},
{"id":60,"theme":["regexp"],"niveau":2,"code":"var str = \"Bonjour\\nVoici un petit texte\\nBonsoir\";\nvar r = /(B.{5}).*(B.{5})/;\n\nalert( r.test(str) );","reponses":["false","true","undefined","Une erreur se produit"],"bonneReponse":"false","explication":"Dans une expression régulière, en JavaScript, le <minicode type=\"javascript\">.</minicode> indique n'importe quel caractère sauf les sauts de ligne (\\r ou \\n).<br>\nBonjour et Bonsoir correspondent bien aux motifs recherchés. Mais entre les deux, il y a des sauts de lignes. Donc le <minicode type=\"javascript\">.</minicode> ne valide pas la chaine.<br>\nPour trouver n'importe quel caractère, y compris les sauts de ligne, il est possible d'utiliser <minicode type=\"javascript\">[\\s\\S]</minicode> qui permet de chercher un caractère qui est soit un caractère \"blanc\" soit un caractère qui n'est pas \"blanc\". Donc tous les caractères correspondent à cette définition.<br>\nPour que l'expression puisse correspondre à cette chaîne, il faudrait écrire&nbsp;: <minicode type=\"javascript\">var r = /(B.{5})[\\s\\S]*(B.{5})/;</minicode>."},
{"id":61,"theme":["portée"],"niveau":0,"code":"var a = 1;\n\nfunction f1(){\n\tvar a = 2;\n\t\n\tfunction f2(){\n\t\tvar a = 3;\n\t}\n\t\n\tf2();\n\talert(a);\n}\n\nf1();","reponses":["1","2","3","undefined","Une erreur se produit"],"bonneReponse":"2","explication":"Dans la fonction <minicode type=\"javascript\">f2</minicode>, la variable <minicode type=\"javascript\">a</minicode> est déclarée localement. Sa modification n'impactera pas les autres variables portant le même nom qu'elle.<br>\nLa demande d'affichage est réalisée dans la fonction <minicode type=\"javascript\">f1</minicode>. La variable <minicode type=\"javascript\">a</minicode> y est déclarée. Ce sera donc cette variable qui sera affichée. Le résultat est donc <minicode type=\"javascript\">2</minicode>."},
{"id":62,"theme":["portée","déclaration"],"niveau":1,"code":"var test = 5;\nfunction essais(condition){\n\tif(condition){\n\t\tvar test = 10;\n\t}\n\talert(test);\n}\n\nessais(false);","reponses":["rien","5","10","undefined","Une erreur se produit"],"bonneReponse":"undefined","explication":"Dans une fonction les variables sont déclarées au tout début de l'exécution de la fonction quel que soit l'endroit où cette déclaration est écrite dans le code. C'est ce qu'on appelle le \"hoisting\". Ainsi la variable <minicode type=\"javascript\">test</minicode> est bien déclarée dans la fonction et est locale à cette fonction. Cependant l'affectation de cette variable n'est réalisée que lorsque l'interpéteur rencontre la ligne en question. Donc <minicode type=\"javascript\">test</minicode> vaut toujours <minicode type=\"javascript\">undefined</minicode> au moment de l'affichage."},
{"id":63,"theme":["portée"],"niveau":4,"code":"var toto = \"abc\";\nfunction f(){\n\talert(\"def\");\n}\n\ntry{\n\tthrow \"une erreur\"; //génère une erreur qui est capturée par le catch\n}catch(toto){\n\ttoto = \"ghi\";\n\tvar f = function() {\n\t   alert(toto);\n\t}\n\tf();\n}","reponses":["\"abc\"","\"def\"","\"ghi\"","undefined","Une erreur survient (qui n'est pas capturée)"],"bonneReponse":"\"ghi\"","explication":"Ceci est une question plutôt facile mais qui peut piéger ceux qui réfléchissent en pensant aux environnements temporaires.<br>\nLa variable <minicode type=\"javascript\">f</minicode> qui est dans le <minicode type=\"javascript\">try … catch</minicode> est déclarée dans l'espace de noms principal (principe du \"hoisting\") et fait référence au même nom que la fonction <minicode type=\"javascript\">f</minicode>. Mais sa nouvelle affectation se fait dans le bloc <minicode type=\"javascript\">catch</minicode> et son espace de noms parent est donc celui de <minicode type=\"javascript\">catch</minicode>. Ainsi <minicode type=\"javascript\">toto</minicode> correspond à celui qui est modifié dans le bloc <minicode type=\"javascript\">catch</minicode>."},
{"id":64,"theme":["portée","fonction"],"niveau":4,"code":"var f = function f(f){\n\treturn typeof f;\n};\n\nalert( f(1) );","reponses":["boolean","function","number","object","string","undefined","Une erreur se produit"],"bonneReponse":"number","explication":"Le but est ici de savoir à quoi fait référence chaque <minicode type=\"javascript\">f</minicode>.<br>\nÀ l'extérieur, c'est naturellement la variable globale qui est utilisée. Celle-ci possède une référence à la fonction <minicode type=\"javascript\">f</minicode>.<br>\nDans la fonction, la variable locale est la première référence à <minicode type=\"javascript\">f</minicode> que rencontre l'interpréteur. <minicode type=\"javascript\">typeof</minicode> s'appliquera donc à la valeur de l'argument.<br>\nLe résultat est donc <minicode type=\"javascript\">\"number\"</minicode>"},
{"id":65,"theme":["portée"],"niveau":0,"code":"var a = 1;\nfunction f1(){\n\tvar a = 2;\n}\n\nfunction f2(){\n\talert(a);\n}\n\nf1();\nf2();","reponses":["1","2","undefined","Une erreur se produit"],"bonneReponse":"1","explication":"Dans la fonction <minicode type=\"javascript\">f1</minicode>, la variable <minicode type=\"javascript\">a</minicode> est déclarée localement. Sa modification n'impactera pas les autres variables portant le même nom qu'elle.<br>\nDans la fonction <minicode type=\"javascript\">f2</minicode>, la variable <minicode type=\"javascript\">a</minicode> n'est pas déclarée. Ce sera donc la variable portant ce nom de l'espace parent qui sera utilisée. C'est donc la variable <minicode type=\"javascript\">a</minicode> déclarée au tout début qui est affichée (et qui vaut toujours <minicode type=\"javascript\">1</minicode>)."},
{"id":66,"theme":["déclaration"],"niveau":1,"code":"function f(){\n\t\n\treturn g;\n\t\n\tfunction g(){\n\t\treturn \"A\";\n\t}\n\n};\n\nvar h = f();\n\nalert( typeof h );","reponses":["boolean","function","number","object","string","undefined","Une erreur se produit"],"bonneReponse":"function","explication":"En JavaScript, les variables sont créées avant le début de l'exécution de la fonction, quel que soit l'endroit où elles sont déclarées dans le code (c'est ce qu'on appelle le \"hoisting\").<br>\nCela signifie qu'il est possible d'appeler une fonction qui est déclarée plus loin dans le code. Et même si celle-ci est déclarée après un <minicode type=\"javascript\">return</minicode> qui met fin à l'exécution du code dans une fonction.<br>\n<br>\nQuand la fonction <minicode type=\"javascript\">f</minicode> est appelée, elle retourne une référence à la fonction <minicode type=\"javascript\">g</minicode>. Donc <minicode type=\"javascript\">h</minicode> possède une référence à la fonction <minicode type=\"javascript\">g</minicode>. Cette fonction n'a pas été appelée donc <minicode type=\"javascript\">typeof h</minicode> vaut <minicode type=\"javascript\">\"function\"</minicode>."},
{"id":67,"theme":["déclaration"],"niveau":2,"code":"function f1(){\n\tvar undefined = true;\n\treturn undefined;\n}\n\nfunction f2(){\n\tundefined = true;\n\treturn undefined;\n}\n\nalert(f1());\nalert(f2());","reponses":["undefined puis undefined","undefined puis true","true puis undefined","true puis true","Une erreur se produit"],"bonneReponse":"true puis undefined","explication":"Depuis Ecmascript 5.1, 'undefined' est un identifiant particulier qui vaut <minicode type=\"javascript\">undefined</minicode>. Cette variable n'est pas \"writable\" et ne peut donc pas être modifiée (<a href=\"http://www.ecma-international.org/publications/standards/Ecma-262.htm\" target=\"_blank\">ECMAScript 5.1</a> section 15.1.1.3).<br>\nToutefois cette variable spéciale n'existe que dans l'espace globale et surtout \"undefined\" n'est pas une variable réservée (cf section 7.6.1). Cela signifie donc qu'il est tout à fait possible de créer une variable nommée \"undefined\" et de lui affecter une valeur.<br>\nRemarque: <minicode type=\"javascript\">NaN</minicode> et <minicode type=\"javascript\">Infinity</minicode> se comporte de la même manière."},
{"id":68,"theme":["fonction"],"niveau":3,"code":"var a = 'global';\nvar o1 = {\n\ta: 'o1',\n\tf: function(){ return this.a; },\n};\nvar o2 = { a: 'o2' };\nvar o3 = { a: 'o3' };\nvar f2 = o1.f.bind(o2);\n\nalert(f2.call(o3));","reponses":["undefined","global","o1","o2","o3","function(){[native code]}","Une erreur se produit"],"bonneReponse":"o2","explication":"Ce qu'il faut savoir c'est que <minicode type=\"javascript\">bind</minicode> attache le contexte de manière permanente. Avec <minicode type=\"javascript\">bind</minicode>, une nouvelle fonction est créée à partir de la fonction de référence. Dans cette fonction, une variable interne <i>BoundThis</i> est créée. Or seule la fonction <minicode type=\"javascript\">bind</minicode> change la valeur de cette variable interne.<br>Lors de l'appel de la fonction, l'interpréteur regarde d'abord si cette variable est définie et sinon lui donne le contexte par défaut. Donc le contexte défini par <minicode type=\"javascript\">bind</minicode> et prioritaire sur le contexte défini par <minicode type=\"javascript\">call</minicode>.<br><br>Pour en savoir plus : <a href=\"http://www.ecma-international.org/publications/standards/Ecma-262.htm\" target=\"_blank\">ECMAScript 5.1</a> aux sections 13.2.1 et 15.3.4.5"},
{"id":69,"theme":["fonction"],"niveau":4,"code":"var a = 'global';\nvar o1 = {\n\ta: 'o1',\n\tf: function(){ return this.a; },\n};\nvar o2 = { a: 'o2' };\nvar o3 = { a: 'o3' };\nvar f2 = o1.f.bind(o2);\nvar f3 = f2.bind(o3);\n\nalert(f3());","reponses":["undefined","global","o1","o2","o3","Une erreur se produit"],"bonneReponse":"o2","explication":"Il faut bien regarder le fonctionnement d'un appel d'une fonction avec <minicode type=\"javascript\">bind</minicode> (section 15.3.4.5.1 de <a href=\"http://www.ecma-international.org/publications/standards/Ecma-262.htm\" target=\"_blank\">ECMAScript 5.1</a>). Lorsqu'on appelle <minicode type=\"javascript\">f3</minicode>, l'interpréteur défini le contexte comme étant celui de <minicode type=\"javascript\">o3</minicode> et appelle <minicode type=\"javascript\">f2</minicode> dans ce contexte. Mais lorsque <minicode type=\"javascript\">f2</minicode> est appelée, l'interpréteur défini alors le nouveau contexte <minicode type=\"javascript\">o2</minicode> et exécute <minicode type=\"javascript\">f</minicode> dans ce contexte."},
{}]}
