1/ identification des fonctions devant être parallèlisées.
Il n'y en a qu'une : chercheSolution

2/
Il faut créer l'appel au fichier de manière dynamique et par un worker

if(window.Worker){
	//le navigateur supporte les workers
	var solutionWorker = new Worker("./solution.js");
	solutionWorker.addEventListener("message",reponseWorker,false);
}else{
	//le navigateur ne supporte pas les Workers, on charge le fichier dynamiquement
	(function(){//pour éviter de polluer l'espace globale
		var script = document.createElement("script");
		script.src="./solution.js";
		document.body.appendChild(script);
	})();
}

3/
Il faut faire attention à plusieurs cas. Par exemple on peut avoir un cas où le jeu se termine avant que la solution ne soit encore trouvé. Dans ce cas dès que nous avons la réponse il faut l'afficher.
Ensuite on a le cas inverse (qui devrait être plus fréquent, où il faudra conserver la réponse jusqu'à la fin du jeu).
Pour pouvoir distinguer ces cas nous allons ajouter une propriété à notre worker (il s'agit d'un objet comme les autres), qui nous servira à conserver la réponse ou indiquer que la réponse doit être anvoyée immédiatement.
Ainsi dans la fonction analyseIA, on sépare les différents cas :
//permet de rechercher une solution et de l'afficher
function analyseIA(){
	if(solutionWorker){
		//les workers sont utilisés
		if(solutionWorker.resultat){
			//le résultat a déjà été trouvé
			affichageIA(solutionWorker.resultat);
		}else{
			//le résultat n'a pas encore été trouvé
			solutionWorker.resultat = -1;
			document.getElementById("resultatIA").textContent = "recherche en cours..."; //on avertit l'utilisateur
		}
	}else{
		//Le worker n'est pas utilisé ainsi on lance la recherche de solutions 
		var liste = [];
		listeNombre.forEach(function(el){
			if(!el.parent1) liste.push(el.valeur);
		}); //récupération des nombres de départ
		affichageIA(chercheSolution(liste,jeuCible.value));
	}

}

//affiche le résultat trouvé par l'ordinateur
function affichageIA(resultat){
	var explication = resultat[1].replace(/\n/g,"<br>");
	if(resultat[0]){
		explication += "<div>Compte approchant : " + resultat[0] + "</div>";
	}else{
		explication += "<div>Le compte est bon !</div>";
	}
	document.getElementById("resultatIA").innerHTML = explication;
}

4/ On peut maintenant s'occuper de la fonction reponseWorker qui analysera la réponse du worker.
//permet d'analyser la réponse du worker
function reponseWorker(event){
	var reponse = event.data.split("|");
	if(solutionWorker.resultat === -1){
		//il faut afficher le resultat tout de suite
		affichageIA(reponse);
	}else{
		//on garde la réponse au chaud
		solutionWorker.resultat = reponse;
	}
}

5/ Pour ce qui est du démarrage du calcul, contrairement à l'architecture sans worker doit se faire au début du jeu. Il faut donc modifier la fonction generateNombre pour démarrer le calcul.
//permet de générer les nombres pour jouer et défini la cible
function generateNombre(){
	var choix = [1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10,25,50,75,100]; //plaques possible
	var nbPlaque = parseInt(document.getElementById("regleNbPlaques").value,10);
	if(listeNombre.length < nbPlaque){
		listeNombre.push(new Nombre(null,null,null,choix[Math.floor(Math.random()*choix.length)]));
		setTimeout(generateNombre,500);
	}else{
		jeuCible.value = Math.floor(Math.random()*898)+101; //le nombre à trouver doit être compris entre 101 et 999		
		if(solutionWorker){
			//on utilise un worker pour trouver la solution
			var liste = "";
			listeNombre.forEach(function(el){liste += el.valeur+",";}); //on prépare la liste des nombres
			liste += jeuCible.value; //on ajoute la cible à la fin de la liste
			solutionWorker.postMessage(liste); //on envoit la liste pour démarrer la recherche
			solutionWorker.resultat = null; //on réinitialise la propriété resultat
		}
		chronometre(); //on démarre le compte à rebours
	}
}


6/
Dans le fichier du worker il reste à créer la gestion du calcul en fonction des messages que l'on reçoit.
//listener qui permet de contrôler le worker
onmessage = function(event){
	var nombres = event.data.split(","); //on récupère la liste des nombres
	var cible = parseInt(nombres.pop(),10); //on récupère la cible
	nombres = nombres.map(function(v){return parseInt(v,10);}); // conversion de toutes les valeurs en nombre
	var resultat = chercheSolution(nombres,cible); //on effectue le calcul
	postMessage(resultat.join("|")); //on renvoit la solution
};

7/ Cas particuliers
Il y a un cas un peu spécial à gérer : Si l'utilisateur demande de recommencer à jouer alors que l'ordinateur est toujours en train de chercher la solution.
Que se passe-t-il ?
Le jeu va recommencer, on aura donc de nouveaux nombres, et ces nombres seront à nouveau envoyer au worker. Or celui-ci est déjà en train de chercher la réponse au jeu précédent (qui a été arrêté). Il ne s'occupera de ces nouveaux nombres que lorsqu'il aura fini avec les premiers.
Ainsi si le jeu se termine avant qu'il ait fini avec ces derniers il affichera la solution des premiers nombres qui n'ont rien avoir avec les nombres en cours.
Et même si on se dit qu'il reste une bonne marge, l'utilisateur peut très bien cliquer sur recommencer 20 fois de suite. Et l'ordinateur recherchera une solution pour tous ces jeux.

Une solution consiste à arrêter le worker grâce à terminate, lorsqu'un nouveau jeu est démarrer. Ainsi pour faire simple il suffit de tuer le worker et d'en recréerun autre à chaque fois qu'on initialise une nouvelle partie, même si le worker avait fini son travail.
Comme le worker peut être créer à différents endroits autant créer une fonction :
//création d'un worker
function createWorker(){
	var w = new Worker("./solution.js");
	w.addEventListener("message",reponseWorker,false);
	return w;
}

if(window.Worker){
	//le navigateur supporte les workers
	var solutionWorker = createWorker();
}

Et dans la fonction initialisation, il suffit d'ajouter :
if(solutionWorker){
	//pour éviter de calculer la solution d'une autre partie
	solutionWorker.terminate();
	solutionWorker = createWorker();
}

Et voilà le jeu est prêt
